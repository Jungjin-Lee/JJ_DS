// Private
var rooms = new Array();
var RoomUserMax = 5;

function makeRoom(player) {
    this.isEmpty = false;
    this.deckIndex = 0;
    this.deck = new Array();
    this.players = new Array(RoomUserMax);
    this.raceMoneys = new Array(RoomUserMax);
    this.players[0] = player;
    this.playersCard = new Array(RoomUserMax * 2);
    this.leader = 0;
    this.turn = 0;  // 첫 번째 0, 두 번째 1
    this.isFull = false;
    this.isRace = true;
    this.raceStopSlot = 0;
    this.perMoney = 1000; // 판돈
    this.money = 0;
    this.turnRaceMoney = 0; // 턴 레이스 금액

    for(var i = 0; i < this.raceMoneys.length; i++) {
      this.raceMoneys[i] = 0;
    }

    for(var i = 0; i < 20; i++) {
      // this.deck.push((i + 1) + "-" + (i + 1));
    }

    this.deck.push("1-1");
    this.deck.push("1-2");
    this.deck.push("2-1");
    this.deck.push("2-2");
    this.deck.push("3-1");
    this.deck.push("3-2");
    this.deck.push("4-1");
    this.deck.push("4-2");
    this.deck.push("5-1");
    this.deck.push("5-2");
    this.deck.push("6-1");
    this.deck.push("6-2");
    this.deck.push("7-1");
    this.deck.push("7-2");
    this.deck.push("8-1");
    this.deck.push("8-2");
    this.deck.push("9-1");
    this.deck.push("9-2");
    this.deck.push("10-1");
    this.deck.push("10-2");
}

// Public
module.exports = {
    Logging: true,

    bar: function () {
        console.log("bar");
    },

    getUserMax: function() {
      return RoomUserMax;
    },

    getRoomCnt: function () {
        return rooms.length;
    },

    connect: function(player) {
        var len = rooms.length;
        for(var i = 0; i < len; i++) {
            var room = rooms[i];
            if(!room.isEmpty && !room.isFull) {
                player.roomNumber = i;
                this.addPlayer(room, player);
                this.fullCheck(room);
                if(this.Logging) console.log("roomconnect success : " + player.roomNumber + " slot:" + player.slot);
                return room;
            }
        }
        if(this.Logging) console.log("roomconnect not empty : ");
        return null;
    },

    addPlayer: function(room, player) {
      for(var i = 0; i < RoomUserMax; i++) {
        if(room.players[i] == null) {
          room.players[i] = player;
          room.isEmpty = false;
          player.isRoom = true;
          player.slot = i;
          player.room = room;
          break;
        }
      }
    },

    fullCheck: function(room) {
      for(var i = 0; i < RoomUserMax; i++) {
        room.isFull = true;
        if(room.players[i] == null) {
          room.isFull = false;
          break;
        }
      }
    },

    join: function(player) {
        var exist = false;
        var len = rooms.length;
        for(var i = 0; i < len; i++) {
            var room = rooms[i];
            if(room.isEmpty) {
                room.roomNumber = i;
                this.addPlayer(room, player);
                if(this.Logging) console.log("roomjoin recycle : " + room.roomNumber);
                return room;
            }
        }
        var newRoom = new makeRoom(player);

        rooms.push(newRoom);
        newRoom.roomNumber = rooms.length - 1;
        player.room = newRoom;
        player.roomNumber = rooms.length - 1;
        player.isRoom = true;
        player.slot = 0;
        if(this.Logging) console.log("roomjoin makeRoom : " + newRoom.roomNumber);
        return newRoom;
    },

    getMySlotAtRoom: function(room, player) {
      var len = room.players.length;
      for(var i = 0; i < len; i++) {
          var p = room.players[i];
          if(p == player) {
              return i;
          }
      }
    },

    allSend: function(room, data) {
        for(var i = 0; i < RoomUserMax; i++) {
            if(room.players[i]) {
                room.players[i].socket.write(data);
            }
        }
    },

    clear: function(player) {
        this.clearRoom(player.room, player);
    },

    clearRoom: function(room, player) {
      player.isRoom = false;
      var len = room.players.length;
      var emptyCnt = 0;
      for(var i = 0; i < len; i++) {
        if(room.players[i] == player) {
            room.players[i] = null;
            room.isFull = false;
            console.log("clearRoom " + i);
        }
        if(room.players[i] == null) {
          emptyCnt++;
        }
      }
      if(emptyCnt == RoomUserMax) {
        room.isEmpty = true;
      }
    },

    shuffle: function(room) {
      for(var i = 0; i < room.deck.length; i++) {
        var r1 = Math.floor(Math.random() * 19);
        var temp = room.deck[i];
        room.deck[i] = room.deck[r1];
        room.deck[r1] = temp;
      }
    },

    start: function(room) {
      var cnt = 0;
      for(var i = 0; i < room.players.length; i++) {
        var p = room.players[i];
        if(p) {
          cnt++;
        }
      }
      if(cnt > 0) {
        room.money = room.perMoney * cnt;
        if(this.Logging) console.log("start : money:" + room.money + " per:" + room.perMoney + " cnt:" + cnt);
      }
    },

    giveCard: function(room, ProtocolManager, n) {
      for(var i = 0; i < room.players.length; i++) {
        var p = room.players[i];
        if(p) {
          var card = room.deck[room.deckIndex];
          room.playersCard[p.slot * 2 + n] = card;
          ProtocolManager.RoomGiveCard_Obj.n = n;
          ProtocolManager.RoomGiveCard_Obj.c = card;
          room.deckIndex++;
          var jsonString = JSON.stringify(ProtocolManager.RoomGiveCard_Obj);
          p.socket.write(jsonString);
          room.turn = n;
          if(this.Logging) console.log("giveCard : room:" + room.roomNumber + " slot:" + p.slot + " card:" + card);
        }
      }
    },

    firstTurnLastRacePlayer: function(room, player) {
      if(room.turn == 0) {
        var i = 4;
        var lastSlot = room.leader - 1;
        while(i > 0) {
          if(lastSlot < 0) {
            lastSlot = 4;
          }
          console.log("i:" + i + " lastSlot:" + lastSlot);

          if(lastSlot == player.slot && room.isRace) {
            room.isRace = false;
            room.raceStopSlot = player.slot;
            if(this.Logging) console.log("firstTurnLastRacePlayer " + player.slot);
            break;
          }
          i--;
          lastSlot--;
        }
      }
    },

    raceHalf: function(room, player) {
      var half = room.money / 2;
      var money = 0;
      if(room.turnRaceMoney > room.raceMoneys[player.slot]) {
        money = room.turnRaceMoney - room.raceMoneys[player.slot];
        room.money += money;
      }
      room.money += half;
      room.raceMoneys[player.slot] += money;
      room.raceMoneys[player.slot] += half;
      room.turnRaceMoney += half;
      if(this.Logging) console.log("raceHalf " + money + " 받고 : " + half + " 더");
      if(this.Logging) console.log("raceHalf : room:" + room.roomNumber + " total:" + (room.money + half) + " money:" + room.money + " half:" + half);
      this.firstTurnLastRacePlayer(room, player);
      return half;
    },

    raceCheck: function(room, player) {
      if(room.isRace) {
        room.raceStopSlot = player.slot;
      }
    },

    raceBbing: function(room, player) {
      var bbing = room.perMoney;
      var money = 0;
      if(room.turnRaceMoney > room.raceMoneys[player.slot]) {
        money = room.turnRaceMoney - room.raceMoneys[player.slot];
        room.money += money;
      }
      room.money += bbing;
      room.raceMoneys[player.slot] += money;
      room.raceMoneys[player.slot] += bbing;
      room.turnRaceMoney += bbing;
      if(this.Logging) console.log("raceBbing : room:" + room.roomNumber + " total:" + (room.money + bbing) + " money:" + room.money + " bbing:" + bbing);
      this.firstTurnLastRacePlayer(room, player);
      return bbing;
    },

    raceCall: function(room, player) {
      if(room.isRace) {
        room.isRace = false;
        room.raceStopSlot = player.slot;
      }
      var money = 0;
      if(room.turnRaceMoney > room.raceMoneys[player.slot]) {
        money = room.turnRaceMoney - room.raceMoneys[player.slot];
        room.money += money;
      }
      room.raceMoneys[player.slot] += money;
      if(this.Logging) console.log("raceCall : " + " turnRaceMoney:" + room.turnRaceMoney + " raceMoneys:" + room.raceMoneys[player.slot] + " money:" + money);
    },

    raceNext: function(room, player, ProtocolManager, type) {
      var slot = player.slot + 1;
      while(1) {
        if(slot >= RoomUserMax) {
          slot = 0;
        }
        if(!room.isRace && slot == room.raceStopSlot) {
        //if(slot == room.leader) {
          if(room.turn == 1) {
            ProtocolManager.RoomGameResult_Obj.playersCard = room.playersCard;
            var jsonString = JSON.stringify(ProtocolManager.RoomGameResult_Obj);
            this.allSend(room, jsonString);
            if(this.Logging) console.log("raceEnd : result:" + jsonString);
            room.isRace = false;
            room.raceStopSlot = 0;
            room.turnRaceMoney = 0;
            for(var i = 0; i < room.raceMoneys.length; i++) {
              room.raceMoneys[i] = 0;
            }
          } else {
            if(this.Logging) console.log("raceEnd : giveCard");
            this.giveCard(room, ProtocolManager, 1);
            var log = "money:" + room.money + " turnRaceMoney:" + room.turnRaceMoney;
            room.isRace = true;
            room.raceStopSlot = 0;
            room.turnRaceMoney = 0;
            for(var i = 0; i < room.raceMoneys.length; i++) {
              if(this.Logging && room.raceMoneys[i] > 0) {
                log += " " + i + ":" + room.raceMoneys[i];
              }
              room.raceMoneys[i] = 0;
            }
            if(this.Logging) console.log("log:" + log);
          }
          break;
        }

        if(room.players[slot]) {
          ProtocolManager.RoomRaceNext_Obj.n = slot;
          ProtocolManager.RoomRaceNext_Obj.type2 = type;
          ProtocolManager.RoomRaceNext_Obj.n2 = player.slot;
          var jsonString = JSON.stringify(ProtocolManager.RoomRaceNext_Obj);
          room.players[slot].socket.write(jsonString);
          if(this.Logging) console.log("raceNext : room:" + room.roomNumber + " slot:" + slot);
          break;
        }
        slot++;
      }
    }
}
