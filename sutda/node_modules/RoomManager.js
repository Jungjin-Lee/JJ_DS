// Private
var rooms = new Array();
var RoomUserMax = 5;

function makeRoom(player) {
    this.isEmpty = false;
    this.deckIndex = 0;
    this.deck = new Array();
    this.players = new Array(RoomUserMax);
    this.players[0] = player;
    this.playersCard = new Array(RoomUserMax * 2);
    this.leader = 0;
    this.turn = 0;
    this.isFull = false;
    this.round = 0;
    this.perMoney = 1000;
    this.money = 0;
    for(var i = 0; i < 20; i++) {
      // this.deck.push((i + 1) + "-" + (i + 1));
    }

    this.deck.push("1-1");
    this.deck.push("1-2");
    this.deck.push("2-1");
    this.deck.push("2-2");
    this.deck.push("3-1");
    this.deck.push("3-2");
    this.deck.push("4-1");
    this.deck.push("4-2");
    this.deck.push("5-1");
    this.deck.push("5-2");
    this.deck.push("6-1");
    this.deck.push("6-2");
    this.deck.push("7-1");
    this.deck.push("7-2");
    this.deck.push("8-1");
    this.deck.push("8-2");
    this.deck.push("9-1");
    this.deck.push("9-2");
    this.deck.push("10-1");
    this.deck.push("10-2");
}

// Public
module.exports = {
    Logging: true,

    bar: function () {
        console.log("bar");
    },

    getUserMax: function() {
      return RoomUserMax;
    },

    getRoomCnt: function () {
        return rooms.length;
    },

    connect: function(player) {
        var len = rooms.length;
        for(var i = 0; i < len; i++) {
            var room = rooms[i];
            if(!room.isEmpty && !room.isFull) {
                player.roomNumber = i;
                this.addPlayer(room, player);
                this.fullCheck(room);
                if(this.Logging) console.log("roomconnect success : " + player.roomNumber + " slot:" + player.slot);
                return room;
            }
        }
        if(this.Logging) console.log("roomconnect not empty : ");
        return null;
    },

    addPlayer: function(room, player) {
      for(var i = 0; i < RoomUserMax; i++) {
        if(room.players[i] == null) {
          room.players[i] = player;
          room.isEmpty = false;
          player.isRoom = true;
          player.slot = i;
          player.room = room;
          break;
        }
      }
    },

    fullCheck: function(room) {
      for(var i = 0; i < RoomUserMax; i++) {
        room.isFull = true;
        if(room.players[i] == null) {
          room.isFull = false;
          break;
        }
      }
    },

    join: function(player) {
        var exist = false;
        var len = rooms.length;
        for(var i = 0; i < len; i++) {
            var room = rooms[i];
            if(room.isEmpty) {
                room.roomNumber = i;
                room.turn = 1;
                this.addPlayer(room, player);
                if(this.Logging) console.log("roomjoin recycle : " + room.roomNumber);
                return room;
            }
        }
        var newRoom = new makeRoom(player);

        rooms.push(newRoom);
        newRoom.roomNumber = rooms.length - 1;
        player.room = newRoom;
        player.roomNumber = rooms.length - 1;
        player.isRoom = true;
        player.slot = 0;
        if(this.Logging) console.log("roomjoin makeRoom : " + newRoom.roomNumber);
        return newRoom;
    },

    getMySlotAtRoom: function(room, player) {
      var len = room.players.length;
      for(var i = 0; i < len; i++) {
          var p = room.players[i];
          if(p == player) {
              return i;
          }
      }
    },

    allSend: function(room, data) {
        for(var i = 0; i < RoomUserMax; i++) {
            if(room.players[i]) {
                room.players[i].socket.write(data);
                if(this.Logging) console.log("allSend : " + i);
            }
        }
    },

    clear: function(player) {
        this.clearRoom(player.room, player);
    },

    clearRoom: function(room, player) {
      player.isRoom = false;
      var len = room.players.length;
      var emptyCnt = 0;
      for(var i = 0; i < len; i++) {
        if(room.players[i] == player) {
            room.players[i] = null;
            room.isFull = false;
            console.log("clearRoom " + i);
        }
        if(room.players[i] == null) {
          emptyCnt++;
        }
      }
      if(emptyCnt == RoomUserMax) {
        room.isEmpty = true;
      }
    },

    shuffle: function(room) {
      for(var i = 0; i < room.deck.length; i++) {
        var r1 = Math.floor(Math.random() * 19);
        var temp = room.deck[i];
        room.deck[i] = room.deck[r1];
        room.deck[r1] = temp;
      }
    },

    start: function(room) {
      var cnt = 0;
      for(var i = 0; i < room.players.length; i++) {
        var p = room.players[i];
        if(p) {
          cnt++;
        }
      }
      if(cnt > 0) {
        room.money = room.perMoney * cnt;
        if(this.Logging) console.log("start : money:" + room.money + " per:" + room.perMoney + " cnt:" + cnt);
      }
    },

    giveCard: function(room, ProtocolManager, n) {
      for(var i = 0; i < room.players.length; i++) {
        var p = room.players[i];
        if(p) {
          var card = room.deck[room.deckIndex];
          room.playersCard[p.slot * 2 + n] = card;
          ProtocolManager.RoomGiveCard_Obj.n = n;
          ProtocolManager.RoomGiveCard_Obj.c = card;
          room.deckIndex++;
          var jsonString = JSON.stringify(ProtocolManager.RoomGiveCard_Obj);
          p.socket.write(jsonString);
          room.round = n;
          if(this.Logging) console.log("giveCard : room:" + room.roomNumber + " slot:" + p.slot + " card:" + card);
        }
      }
    },

    race: function(room, player) {
      var half = room.money / 2;
      if(this.Logging) console.log("raceHalf : room:" + room.roomNumber + " total:" + (room.money + half) + " money:" + room.money + " half:" + half);
      room.money += half;
    },

    raceNext: function(room, player, ProtocolManager, type) {
      var slot = player.slot + 1;
      while(1) {
        if(slot >= RoomUserMax) {
          slot = 0;
        }
        if(slot == room.leader) {
          if(room.round == 1) {
            ProtocolManager.RoomGameResult_Obj.playersCard = room.playersCard;
            var jsonString = JSON.stringify(ProtocolManager.RoomGameResult_Obj);
            this.allSend(room, jsonString);
            if(this.Logging) console.log("raceEnd : result:" + jsonString);
          } else {
            if(this.Logging) console.log("raceEnd : giveCard");
            this.giveCard(room, ProtocolManager, 1);
          }
          break;
        }

        if(room.players[slot]) {
          room.turn = slot;
          ProtocolManager.RoomRaceNext_Obj.n = slot;
          ProtocolManager.RoomRaceNext_Obj.type = type;
          var jsonString = JSON.stringify(ProtocolManager.RoomRaceNext_Obj);
          room.players[slot].socket.write(jsonString);
          if(this.Logging) console.log("raceNext : room:" + room.roomNumber + " slot:" + slot);
          break;
        }
        slot++;
      }
    }
}
